<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FalkorDB Canvas Web Component Example</title>

  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      color: #333;
      margin-bottom: 20px;
    }

    .graph-container {
      height: 600px;
      width: 100%;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .controls {
      margin-bottom: 20px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    button {
      margin-right: 10px;
      padding: 8px 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #45a049;
    }

    .info {
      margin-top: 20px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    #selected-info {
      color: #666;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>FalkorDB Canvas Web Component</h1>

    <div class="controls">
      <button onclick="addNode()">Add Node</button>
      <button onclick="addLink()">Add Link</button>
      <button onclick="toggleLoading()">Toggle Loading</button>
    </div>

    <div class="graph-container">
      <falkordb-canvas id="graph"></falkordb-canvas>
    </div>

    <div class="info">
      <h3>Selected Element:</h3>
      <div id="selected-info">Click on a node or link to see details</div>
    </div>
  </div>

  <!-- Import map for module resolution -->
  <script type="importmap">
    {
      "imports": {
        "d3": "https://cdn.jsdelivr.net/npm/d3@7.9.0/+esm",
        "force-graph": "https://cdn.jsdelivr.net/npm/force-graph@1.51.0/+esm"
      }
    }
  </script>

  <!-- Import the web component -->
  <script type="module">
    import 'https://cdn.jsdelivr.net/npm/@falkordb/canvas@0.0.16/dist/index.js';

    // Define control functions FIRST so they're available immediately for onclick handlers
    let canvas;
    let nodeCounter = 1;
    let linkCounter = 1;

    window.addNode = () => {
      if (!canvas) {
        alert('Graph not loaded yet, please wait...');
        return;
      }
      const data = canvas.getData();
      const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#96CEB4'];
      data.nodes.push({
        id: nodeCounter,
        labels: ['Person'],
        color: colors[Math.floor(Math.random() * colors.length)],
        visible: true,
        data: { name: `Person ${nodeCounter}` }
      });
      nodeCounter++;
      canvas.setData(data);
    };

    window.addLink = () => {
      if (!canvas) {
        alert('Graph not loaded yet, please wait...');
        return;
      }
      const data = canvas.getData();
      if (data.nodes.length < 2) {
        alert('Need at least 2 nodes to create a link');
        return;
      }
      const sourceIdx = Math.floor(Math.random() * data.nodes.length);
      let targetIdx = Math.floor(Math.random() * data.nodes.length);
      while (targetIdx === sourceIdx && data.nodes.length > 1) {
        targetIdx = Math.floor(Math.random() * data.nodes.length);
      }
      data.links.push({
        id: linkCounter,
        relationship: 'CONNECTS',
        color: '#999',
        source: data.nodes[sourceIdx].id,
        target: data.nodes[targetIdx].id,
        visible: true,
        data: {}
      });
      linkCounter++;
      canvas.setData(data);
    };

    let isLoading = false;
    window.toggleLoading = () => {
      if (!canvas) {
        alert('Graph not loaded yet, please wait...');
        return;
      }
      isLoading = !isLoading;
      canvas.setIsLoading(isLoading);
      canvas.setCooldownTicks(isLoading ? undefined : 300);
    };

    // Now load the graph data
    const API_TOKEN = 'your-api-token';
    const graphName = 'your-graph';
    const query = 'your-query'; // MATCH (n) OPTIONAL MATCH (n)-[e]->(m) RETURN * LIMIT 100

    const url = `https://browser.falkordb.com/api/graph/${encodeURIComponent(graphName)}?query=${encodeURIComponent(query)}`;

    let graphData = { nodes: [], links: [] };

    // Color palettes
    const labelColors = {};
    const relationshipColors = {};
    const colorPalette = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#96CEB4',
      '#FFEAA7', '#DFE6E9', '#74B9FF', '#A29BFE', '#FD79A8',
      '#FDCB6E', '#6C5CE7', '#00B894', '#E17055', '#0984E3'
    ];
    let colorIndex = 0;

    // Helper function to get color for a label
    const getColorForLabel = (label) => {
      if (!labelColors[label]) {
        labelColors[label] = colorPalette[colorIndex % colorPalette.length];
        colorIndex++;
      }
      return labelColors[label];
    };

    // Helper function to get color for a relationship type
    const getColorForRelationship = (type) => {
      if (!relationshipColors[type]) {
        relationshipColors[type] = colorPalette[colorIndex % colorPalette.length];
        colorIndex++;
      }
      return relationshipColors[type];
    };

    try {
      // Use fetch with manual SSE parsing (simpler than polyfill)
      await new Promise(async (resolve, reject) => {
        try {
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${API_TOKEN}`,
            }
          });

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });

            // Process complete events
            const events = buffer.split('\n\n');
            buffer = events.pop(); // Keep incomplete event in buffer

            for (const event of events) {
              if (!event.trim()) continue;

              const lines = event.split('\n');
              let eventType = '';
              let data = '';

              for (const line of lines) {
                if (line.startsWith('event:')) {
                  eventType = line.substring(6).trim();
                } else if (line.startsWith('data:')) {
                  data += line.substring(5);
                }
              }

              if (eventType === 'result' && data) {
                const result = JSON.parse(data);
                console.log('Query result:', result);

                // Convert to falkordb-canvas format
                if (result.data && Array.isArray(result.data)) {
                  result.data.forEach(row => {
                    if (row.n) {
                      const primaryLabel = row.n.labels[0] || 'Unknown';
                      const node = {
                        id: row.n.id,
                        labels: row.n.labels,
                        data: row.n.properties,
                        visible: true,
                        color: getColorForLabel(primaryLabel)
                      };
                      // Avoid duplicates
                      if (!graphData.nodes.find(n => n.id === node.id)) {
                        graphData.nodes.push(node);
                      }
                    }
                    // Add target node if present
                    if (row.m) {
                      const primaryLabel = row.m.labels[0] || 'Unknown';
                      const targetNode = {
                        id: row.m.id,
                        labels: row.m.labels,
                        data: row.m.properties,
                        visible: true,
                        color: getColorForLabel(primaryLabel)
                      };
                      if (!graphData.nodes.find(n => n.id === targetNode.id)) {
                        graphData.nodes.push(targetNode);
                      }
                    }
                    // Add links if relationship present
                    if (row.e && row.n && row.m) {
                      const relType = row.e.relationshipType || 'RELATED';
                      const link = {
                        id: row.e.id,
                        source: row.e.sourceId,
                        target: row.e.destinationId,
                        relationship: relType,
                        data: row.e.properties || {},
                        color: getColorForRelationship(relType),
                        visible: true
                      };
                      if (!graphData.links.find(l => l.id === link.id)) {
                        graphData.links.push(link);
                      }
                    }
                  });
                }

                resolve(result);
              } else if (eventType === 'error' && data) {
                const { message } = JSON.parse(data);
                console.error('Error:', message);
                reject(new Error(message));
              }
            }
          }
        } catch (error) {
          console.error('Fetch error:', error);
          reject(error);
        }
      });
    } catch (error) {
      alert(error.message);
    }

    // Get the graph element
    canvas = document.getElementById('graph');

    // Wait for the element to be defined
    await customElements.whenDefined('falkordb-canvas');

    // Set initial data
    canvas.setData(graphData);

    const graphContainer = document.querySelector('.graph-container');

    // Configure the graph using individual setters (more efficient!)
    canvas.setWidth(graphContainer.clientWidth);
    canvas.setHeight(graphContainer.clientHeight);

    // Set event handlers using setConfig (for callbacks)
    canvas.setConfig({
      cooldownTicks: undefined,
      autoStopOnSettle: false,
      onNodeClick: (node, event) => {
        console.log('Node clicked:', node);
        document.getElementById('selected-info').textContent =
          `Node: ${node.data.name || node.id} (${node.labels.join(', ')})`;
      },
      onLinkClick: (link, event) => {
        console.log('Link clicked:', link);
        document.getElementById('selected-info').textContent =
          `Link: ${link.relationship}`;
      },
      onNodeRightClick: (node, event) => {
        console.log('Node right-clicked:', node);
        document.getElementById('selected-info').textContent =
          `Right-clicked Node: ${node.data.name || node.id}`;
      },
      onLinkRightClick: (link, event) => {
        console.log('Link right-clicked:', link);
        document.getElementById('selected-info').textContent =
          `Right-clicked Link: ${link.relationship}`;
      },
      onNodeHover: (node) => {
        if (node) {
          console.log('Node hover:', node);
        }
      },
      onLinkHover: (link) => {
        if (link) {
          console.log('Link hover:', link);
        }
      },
      onBackgroundClick: () => {
        document.getElementById('selected-info').textContent =
          'Click on a node or link to see details';
      },
      isNodeSelected: (node) => false,
      isLinkSelected: (link) => false,
    });

    // Update counters based on loaded data
    nodeCounter = Math.max(...graphData.nodes.map(n => n.id), 0) + 1;
    linkCounter = Math.max(...graphData.links.map(l => l.id), 0) + 1;
  </script>
</body>

</html>